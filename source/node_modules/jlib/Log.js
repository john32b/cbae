/**
 * Generic Logger
 * - Includes code from the NPM package : https://github.com/jinweizhiyuan/logger-line-number
 * 
 * DEV:
 * 
 * - All terminals display STDOUT+STDERR by default
 * 
 ****************************************************************/


const PATH = require('path');
const FS = require('fs');

// -------------------------------------------------------;
// LOG LEVELS:
// 0:None 1:Error 2:Warning 3:Normal 4:Debug
// -------------------------------------------------------;l

/** Default parameters. You can override these on init() */
const PARAMS = {
	date: "HH:MM:SS",		// Date format, null or "" for no date | FULL : "YYYY-mm-dd HH:MM:SS"
	pos: false,				// Log the file position
	stderr: false,			// Log to stderr (will output to console, as all terminal do by default)
	bufferSize: 2000,		// How many logs to keep in memory
	file: null,				// If set at init, will start logging to it
	level: -1				// Initial Log Level (0:none,1:error,2:warning,3:normal,4:debug)
}

let loglvl = 3; 			// (3:LOG) Active log level | anything higher than that will not log
let buffer = [];			// Keeps all log messages
let logFile = null;			// Path of file to log. Null for no file.


/** Set multiple parameters at once
 * Usually called in Development
 * Log Level : 0:None 1:Error 2:Warning 3:Normal 4:Debug
 * @param {{date:String, pos:Boolean, stderr:Boolean, bufferSize:Number, file:String, level:Number}} p
*/
function set(p) {
	Object.assign(PARAMS, p);
	if (PARAMS.file) setLogFile(PARAMS.file);
	if (PARAMS.level >= 0) {
		loglvl = PARAMS.level;
		if (loglvl < 0) loglvl = 0; else if (loglvl > 4) loglvl = 4;
	}
}// -------------------------;

/**
 * Set a file to write the log. If it exists, will be overwritten.
 * @param {string} path Path of a log file to write.
 */
function setLogFile(path) 
{
	if (logFile == path) return; // Rare case e.g. When you want to call set() again to change something
	logFile = path;
	let line = '-'.repeat(40);
	let header =
` == LOG ==
 ${line}
 - LogFile : ${logFile}
 - Created : ${dateFormat("YYYY-mm-dd HH:MM:SS")} 
 - Script  : ${process.argv[1]}
 ${line}
`; // < end with new line
   // < Keep this at most left, since whiteSpace matters

	try {
		FS.writeFileSync(logFile, header); // utf8 is default
	} catch (e) {
		logFile = null;
		error(`Cannot Create Log File &{logFile}`);
		return;
	}
	// There is a case where the log array has data,
	// write that data to the file.
	for (let m of buffer) pushFile(m);
}//-------------------------;

/**
 * DEV: This has got to be a separate function, don't merge
 */
let getStackTrace = function () {
	let obj = {};
	Error.captureStackTrace(obj, getStackTrace) // Error.captureStackTrace to capture the stack-trace where you throw the error.
	return obj.stack
}//-------------------------;


/**
 * Write a string to current logfile.
 * [DEV] logfile was checked before on <setLogFile()>
 */
 function pushFile(str) {
	try {
		FS.appendFileSync(logFile, str + '\n');
	} catch (e) {
		logFile = null;	// Don't call for writes anymore
		error("Cannot write to LOG FILE");
	}
}//-------------------------;


/** Helper */
function dateFormat(fmt, date) {
	if (!date) date = new Date()
	var opt = {
		"Y+": date.getFullYear().toString(),
		"m+": (date.getMonth() + 1).toString(),
		"d+": date.getDate().toString(),
		"H+": date.getHours().toString(),
		"M+": date.getMinutes().toString(),
		"S+": date.getSeconds().toString(),
	}

	for (let k in opt) {
		let reg = new RegExp("(" + k + ")")
		let match = reg.exec(fmt)
		if (match) {
			fmt = fmt.replace(match[1], match[1].length == 1 ? opt[k] : opt[k].padStart(match[1].length, "0"))
		}
	}

	return fmt
}//-------------------------;


/**
 * Called by the more specific functions and does the actual logging  
 * Multiple Argument Function 
 * DEV: 
 *   ...args, puts all the arguments on an array
 */
function logMain(...args) {

	let str = args.shift() + ' ';

	if (PARAMS.date) {	// works with null and ""
		str += `${dateFormat(PARAMS.date)}:`;
	}

	if (PARAMS.pos) {
		let stack = getStackTrace();
		let matchstack = stack.match(/\(.*?\)/g) || [];
		let line = matchstack[2] || "";
		// Full line is e.g. | (C:\code\Myapp\app.js:32:3)
		let fileAndLine = line.substring(line.lastIndexOf(PATH.sep) + 1, line.length - 1);
		str += `(${fileAndLine}) `;
	}
	// str is the first part of the log e.g. | "01:18:02 (app.js:33:3) [INFO] "

	// Log to console.log NOW before building the str object more
	// it provides a different format for printing objects and arrays
	if (PARAMS.stderr) {
		console.error(str, ...args); // Write to STDERR
	}

	// Construct a string with the rest of the arguments
	str += args.reduce((p, c) => {
		if (typeof c == "object") {
			if (Array.isArray(c)) return '[' + c.toString() + ']';
			return p + ' ' + JSON.stringify(c, null, 2);
		} else {
			if (typeof c == "function") return p + "";	// No functions
			return p + ' ' + c; // else must be number or string
		}
	});

	// --
	buffer.push(str);

	if (buffer.length > PARAMS.bufferSize) buffer.shift();	// remove the oldest;

	if (logFile) pushFile(str);	// convert to string

}//-------------------------;

/** Log Debug - Supports multiple arguments */
function debug() {
	if (loglvl < 4) return
	logMain('DEBUG', ...arguments);
}//-------------------------;

/** Log - Supports multiple arguments */
function log() {
	if (loglvl < 3) return
	logMain('LOG', ...arguments);
}//-------------------------;

/** Log Warning - Supports multiple arguments */
function warn() {
	if (loglvl < 2) return;
	logMain('WARNING', ...arguments);
}// -------------------------;

/** Log Error - Supports multiple arguments */
function error() {
	if (loglvl < 1) return
	logMain('ERROR', ...arguments);
}//-------------------------;



module.exports = {
	set,					// Initialize with custom parameters, check PARAMS
	log, error, debug, warn,// Call these to log
	get BUFFER() { return buffer; }	// Get the entire log buffer, {String[]}
}

