/**
 * Terminal TTY Interface
 * 
 * - Basic things like cursor and colors
 * - Some extras, like parsing tags, autocolor
 * 
 ************************************************************/


const { EOL } = require('os');
const { stdout } = require('process');


class Terminal
{	
	// The escape Sequence can also be '\033[', or even '\e[' in linux ''
	// I am not using the escape sequence as a reference anywhere, as hard typing is faster.
	_ESC_SEQ 		= '\x1B['; 	
	_BOLD 			= '\x1B[1m';
	_DIM 			= '\x1B[2m';
	_ITAL 			= '\x1B[3m';
	_UNDERL			= '\x1B[4m';
	_BLINK 			= '\x1B[5m';
	_HIDDEN 		= '\x1B[8m';
	_RESET_ALL 		= '\x1B[0m';
	_RESET_FG	 	= '\x1B[39m';	// Default color
	_RESET_BG 		= '\x1B[49m';
	_RESET_BOLD 	= '\x1B[21m';
	_RESET_DIM 		= '\x1B[22m';
	_RESET_ITAL		= '\x1B[23m';
	_RESET_UNDERL	= '\x1B[24m';
	_RESET_BLINK	= '\x1B[25m';
	_RESET_HIDDEN	= '\x1B[28m';
	_CURSOR_SAV		= '\x1B[s';
	_CURSOR_RES		= '\x1B[u';
	_NL				= EOL;		// Windows is '\r\n' | Linux is '\n'
	
	COLORS_FG = new Map([
		['darkgray',	'\x1B[90m'],
		['red',			'\x1B[91m'],
		['green',		'\x1B[92m'],
		['yellow',		'\x1B[93m'],
		['blue',		'\x1B[94m'],
		['magenta',		'\x1B[95m'],
		['cyan',		'\x1B[96m'],
		['white',		'\x1B[97m'],
		['black',		'\x1B[30m'],
		['darkred',		'\x1B[31m'],
		['darkgreen',	'\x1B[32m'],
		['darkyellow',	'\x1B[33m'],
		['darkblue',	'\x1B[34m'],
		['darkmagenta',	'\x1B[35m'],
		['darkcyan',	'\x1B[36m'],
		['gray', 		'\x1B[37m']	
	]);	
	
	COLORS_BG = new Map([
		['darkgray',	'\x1B[100m'],
		['red',			'\x1B[101m'],
		['green',		'\x1B[102m'],
		['yellow',		'\x1B[103m'],
		['blue',		'\x1B[104m'],
		['magenta',		'\x1B[105m'],
		['cyan',		'\x1B[106m'],
		['white',		'\x1B[107m'],
		['black',		'\x1B[40m'],
		['darkred',		'\x1B[41m'],
		['darkgreen',	'\x1B[42m'],
		['darkyellow',	'\x1B[43m'],
		['darkblue',	'\x1B[44m'],
		['darkmagenta',	'\x1B[45m'],
		['darkcyan',	'\x1B[46m'],
		['gray', 		'\x1B[47m']	
	]);


	/** @param {Boolean} enable Enable or Disable the cursor. Mostly used in a TUI */
	setCur(enable) { 
		return this.print(enable?"\x1B[?25h":"\x1B[?25l"); 
	}

	saveCur() {
		return this.print(this._CURSOR_SAV);
	}

	restCur() {
		return this.print(this._CURSOR_RES);
	}

	/** Cursor Up */
	up(a = 1) {
		return this.print('\x1B[${x}A');
	}
	/** Cursor Down */
	down(a = 1) {
		return this.print('\x1B[${x}B');
	}
	/** Cursor Right */
	forward(a = 1) {
		return this.print('\x1B[${x}C');
	}
	/** Cursor Left */
	back(a = 1) {
		return this.print('\x1B[${x}D');
	}
	
	/** Cursor Move Absolute - Starting from (1,1)
	 * Moves the cursor to a specific X and Y position on the Terminal */
	move(x, y) {
		process.stdout.cursorTo(x - 1, y - 1);
	}

	/** Cursor Move Relative */
	moveR(x, y) {
		process.stdout.moveCursor(x, y);
	}

	/** Print to the terminal */
	print(str) {
		stdout.write(str);
		return this;
	}//---------------------------------------------------;
	
	/** Print to the terminal, add newline */
	println(str) {
		stdout.write(str + EOL);
		return this;
	}//---------------------------------------------------;


	/**
	 * Clear a line with a direction (-1,0,1)
	 * Leaves the cursor where it was
	 * @param {Number} d DIR -1:Left of cursor | 1:Right of Cursor | 0:Entire Line
	 */
	clearLine(d=0)
	{
		stdout.clearLine(d);
		return this;
		// DEV: The ANSI did'n work?
		// return this.print(`\x1B[${d}K`);
	}// -------------------------;

	
	/**
	 * Sets the color of the cursor (Foreground color)
	 * @param {String} col Set color. Null for reset
	 */
	fg(col) {
		if (!col) return this.print(this._RESET_FG);
		return this.print(this.COLORS_FG.get(col));
	}//---------------------------------------------------;
	
	/**
	 * Sets the color of the background
	 * @param {String} col Set color. Null for reset
	 */
	bg(col) {
		if (!col) return this.print(this._RESET_BG);
		return this.print(this.COLORS_BG.get(col));
	}//---------------------------------------------------;
	
	/** Resets all styles */
	reset() { return this.print(this._RESET_ALL) ;}

	/** End line, print EOL -- will be deprecated -- */
	endl() { return this.print(EOL); } 

	/** Shorter endl(); @param  {Number} c Repeat the operation */
	n(c=1) { return this.print(EOL.repeat(c)); } // SHORTER endl(); also multiple parameter


	/**
	 * Print a Tag Formatted String
	 * @param {String} s String to print. Supports special <tags> check parseTags()
	 */
	ptag(s) {
		return this.print(this.parseTags(s));
	}//---------------------------------------------------;
	

	/**
	 * Transform a string with tags to a string with escape codes
	 * Tags are found within <> and can be separated by ,
	 * e.g. <red,bold,:blue>  -> red color,bold,blue background
	 * @throws
	 */
	parseTags(str)
	{
		const res = /<(\S+?)>/g;
		str = str.replace(res,(A,B)=>{
			let prop = B.split(','); 	// All Tag Properties e.g. ['red','bg:white']
			let ret="";	// The string to return
			for(let p of prop) {
				switch(p) {
					case "n"	: ret+=EOL; break;	// NEWLINE
					case "t"	: ret+='\t'; break;	// TAB
					case "!" 	: ret+=this._RESET_ALL; break;
					case "!fg" 	: ret+=this._RESET_ALL; break;
					case "!bg" 	: ret+=this._RESET_ALL; break;
					case "cs" 	: ret+=this._CURSOR_SAV; break;
					case "cr" 	: ret+=this._CURSOR_RES; break;
					case "bold" : ret+=this._BOLD; break;
					case "!bold" : ret+=this._RESET_BOLD; break;
					case "underl" : ret+=this._UNDERL; break;
					case "!underl" : ret+=this._RESET_UNDERL; break;
					case "it" : ret+=this._ITAL; break;
					case "!it" : ret+=this._RESET_ITAL; break;
					
					// .. more cases missing from HAXE code
					// .. I could use a MAP here
					
					default:
						// Check BG (BG colors start with : e.g. `:red`
						if (p.indexOf(':') == 0) {
							let col = p.split(':')[1];
							if(this.COLORS_BG.has(col)){
								ret+=this.COLORS_BG.get(col);
							}else{
								throw new Error(`Tag Error: Color Error ${A}`);
							}
						}else{
						// If not BG, then it must be normal Color
							if(this.COLORS_FG.get(p)){
								ret+=this.COLORS_FG.get(p);
							}else{
								// DEV: Could I throw an error here?
								// throw new Error(`Tag Error: Color Error ${A}`);
								ret+=A;
							}
						}
				}//-- end switch
			}//-- end for
			return ret;
		});

		return str;
	}//---------------------------------------------------;

	/** Strip Tags
	 * Gets a string with tags <...> and returns a string with no tags
	 * Useful for transforming strings for logging
	 **/
	st(str)
	{
		return str.replace(/<(\S+?)>/g, "");
	}// -------------------------------------------------------;


	/** Print and Autocolorize Text */
	pac(str)
	{
		return this.ptag(this.autoColor(str));
	}// -------------------------;


	/**
	* Autocolorize a string
	* Takes a not-tagged string and creates color tags for use with Terminal.ptag();
	* It colorizes strings,parentheses,brackes  " ' ( [
	* Useful to printing to console generic messages like ::
	* 		Cannot create file "./config.json" Tried (30) times
 	* @param {String} str
	**/
	autoColor(str)
	{
		let reg = /\b(\d+)|\[(.+?)\]|\{(.+?)\}|'(.+?)'|"(.+?)"|([\-+=:()?<>]+)/g;
		// 1 : Numbers on their own
		// 2 : [text in] []	
		// 3 : {text in} {}
		// 4 : 'strings'
		// 5 : "strings"
		// 6 : symbols -+=()?<>[]
		return str.replace(reg, (m, p1, p2, p3, p4, p5, p6) => {
			if(p1) return `<cyan>${m}<!>`;
			if(p2) return `<green,bold>${m}<!>`;
			if(p3) return `<red,bold>${m}<!>`;
			if(p4) return `<magenta,it>${m}<!>`;	
			if(p5) return `<yellow>${m}<!>`;
			if(p6) return `<yellow,bold>${m}<!>`;
			return "X";
		});
	}// -------------------------;
	
}// -- end object --


module.exports = new Terminal();