/**
 * Terminal TTY Interface
 *
 * - Basic things like cursor and colors
 * - Some extras, like parsing tags, autocolor
 *
 *
 * Default Export : Terminal Object
 * import T from 'jlib/Terminal'	// suggestion
 *
 ************************************************************/
import { EOL } from 'node:os';
import { stdout } from 'node:process';
var COLORS_FG = new Map([
    ['darkgray', '\x1B[90m'],
    ['red', '\x1B[91m'],
    ['green', '\x1B[92m'],
    ['yellow', '\x1B[93m'],
    ['blue', '\x1B[94m'],
    ['magenta', '\x1B[95m'],
    ['cyan', '\x1B[96m'],
    ['white', '\x1B[97m'],
    ['black', '\x1B[30m'],
    ['darkred', '\x1B[31m'],
    ['darkgreen', '\x1B[32m'],
    ['darkyellow', '\x1B[33m'],
    ['darkblue', '\x1B[34m'],
    ['darkmagenta', '\x1B[35m'],
    ['darkcyan', '\x1B[36m'],
    ['gray', '\x1B[37m']
]);
var COLORS_BG = new Map([
    ['darkgray', '\x1B[100m'],
    ['red', '\x1B[101m'],
    ['green', '\x1B[102m'],
    ['yellow', '\x1B[103m'],
    ['blue', '\x1B[104m'],
    ['magenta', '\x1B[105m'],
    ['cyan', '\x1B[106m'],
    ['white', '\x1B[107m'],
    ['black', '\x1B[40m'],
    ['darkred', '\x1B[41m'],
    ['darkgreen', '\x1B[42m'],
    ['darkyellow', '\x1B[43m'],
    ['darkblue', '\x1B[44m'],
    ['darkmagenta', '\x1B[45m'],
    ['darkcyan', '\x1B[46m'],
    ['gray', '\x1B[47m']
]);
;
// Why a Class?
// Because I want to be able to chain the function returns
// e.g. T.print("hello").clear().bold().print("world");
class Terminal {
    // Quick Access to OS EOL symbol
    EOL = EOL;
    /** Print to the terminal */
    print(str) {
        stdout.write(str);
        return this;
    }
    /** Print to the terminal, adds a newline */
    println(str) {
        stdout.write(str + EOL);
        return this;
    }
    /** New Line
     * @param c Repeat the operation N times*/
    n(c = 1) { return this.print(EOL.repeat(c)); }
    /** Sets the color of the cursor (Foreground color)
     * @param col Color in `COLORS_FG`. Null to reset.
     */
    fg(col) {
        if (!col)
            return this.print("\u001B[39m" /* SP.RESET_FG */);
        return this.print(COLORS_FG.get(col));
    }
    /** Sets the color of the background
     * @param col Color in `COLORS_BG`. Null to reset.
     */
    bg(col) {
        if (!col)
            return this.print("\u001B[49m" /* SP.RESET_BG */);
        return this.print(COLORS_BG.get(col));
    }
    /** Resets all colors/styles */
    reset() { return this.print("\u001B[0m" /* SP.RESET_ALL */); }
    /** Clear a line with a direction (-1,0,1)
     * Leaves the cursor where it was
     * @param d Direction -1:Left of cursor | 1:Right of Cursor | (0:Entire Line)
     */
    clearLine(d = 0) {
        stdout.clearLine(d);
        return this;
    } // -------------------------;
    /** @param enable Enable or Disable the cursor. (Mostly used in a TUI) */
    setCur(show = true) {
        return this.print(show ? "\u001B[?25h" /* SP.CURSOR_SHOW */ : "\u001B[?25l" /* SP.CURSOR_HIDE */);
    }
    /** Save Cursor Position */
    saveCur() {
        return this.print("\u001B[s" /* SP.CURSOR_SAV */);
    }
    /** Restore Cursor */
    loadCur() {
        return this.print("\u001B[u" /* SP.CURSOR_RES */);
    }
    /** Cursor Up */
    up(a = 1) {
        return this.print(`\x1B[${a}A`);
    }
    /** Cursor Down */
    down(a = 1) {
        return this.print(`\x1B[${a}B`);
    }
    /** Cursor Right */
    forward(a = 1) {
        return this.print(`\x1B[${a}C`);
    }
    /** Cursor Left */
    back(a = 1) {
        return this.print(`\x1B[${a}D`);
    }
    /** Cursor Move Absolute - Starting from (1,1)
    * Moves the cursor to a specific X and Y position on the Terminal */
    move(x, y) {
        process.stdout.cursorTo(x - 1, y - 1);
    }
    /** Cursor Move Relative */
    moveR(x, y) {
        process.stdout.moveCursor(x, y);
    }
    // --------------------------------------------
    // Advanced Printing
    // --------------------------------------------
    /** Print a Tag Formatted String
    * @param s String to print. Supports special <tags> check parseTags()
    */
    ptag(s) {
        return this.print(this.parseTags(s));
    } // -------------------------------------------------------;
    /** Print and Autocolorize Text */
    pac(str) {
        return this.ptag(this.autoColor(str));
    } // -------------------------------------------------------;
    /** Strip Tags
     * Gets a string with tags <...> and returns a string with no tags
     * Useful for transforming strings for logging
     * DEV: Put this in Terminal Tools ?
     **/
    st(str) {
        return str.replace(/<(\S+?)>/g, "");
    } // -------------------------------------------------------;
    /**
    * Autocolorize a string
    * Takes a not-tagged string and creates color tags for use with Terminal.ptag();
    * It colorizes strings,parentheses,brackes  " ' ( [
    * Useful to printing to console generic messages like ::
    * 		Cannot create file "./config.json" Tried (30) times
    **/
    autoColor(str) {
        let reg = /\b(\d+)|\[(.+?)\]|\{(.+?)\}|'(.+?)'|"(.+?)"|([\-+=:()?<>]+)/g;
        // 1 : Numbers on their own
        // 2 : [text in] []	
        // 3 : {text in} {}
        // 4 : 'strings'
        // 5 : "strings"
        // 6 : symbols -+=()?<>[]
        return str.replace(reg, (m, p1, p2, p3, p4, p5, p6) => {
            if (p1)
                return `<cyan>${m}<!>`;
            if (p2)
                return `<green,bold>${m}<!>`;
            if (p3)
                return `<red,bold>${m}<!>`;
            if (p4)
                return `<magenta,it>${m}<!>`;
            if (p5)
                return `<yellow>${m}<!>`;
            if (p6)
                return `<yellow,bold>${m}<!>`;
            return "X";
        });
    } // -------------------------------------------------------;
    /** Transform a string with tags to a string with escape codes
     * Tags are found within <> and can be separated by ,
     * e.g. <red,bold,:blue>  -> red color,bold,blue background
     * @throws Errors
     * @returns Parsed String, ready to be printed
     */
    parseTags(str) {
        const res = /<(\S+?)>/g;
        str = str.replace(res, (A, B) => {
            let prop = B.split(','); // All Tag Properties e.g. ['red','bg:white']
            let ret = ""; // The string to return
            for (let p of prop) {
                switch (p) {
                    case "n":
                        ret += EOL;
                        break; // NEWLINE
                    case "t":
                        ret += '\t';
                        break; // TAB
                    case "!":
                        ret += "\u001B[0m" /* SP.RESET_ALL */;
                        break;
                    case "!fg":
                        ret += "\u001B[0m" /* SP.RESET_ALL */;
                        break;
                    case "!bg":
                        ret += "\u001B[0m" /* SP.RESET_ALL */;
                        break;
                    case "cs":
                        ret += "\u001B[s" /* SP.CURSOR_SAV */;
                        break;
                    case "cr":
                        ret += "\u001B[u" /* SP.CURSOR_RES */;
                        break;
                    case "bold":
                        ret += "\u001B[1m" /* SP.BOLD */;
                        break;
                    case "!bold":
                        ret += "\u001B[21m" /* SP.RESET_BOLD */;
                        break;
                    case "underl":
                        ret += "\u001B[4m" /* SP.UNDERL */;
                        break;
                    case "!underl":
                        ret += "\u001B[24m" /* SP.RESET_UNDERL */;
                        break;
                    case "it":
                        ret += "\u001B[3m" /* SP.ITAL */;
                        break;
                    case "!it":
                        ret += "\u001B[23m" /* SP.RESET_ITAL */;
                        break;
                    // .. more cases missing from HAXE code
                    // .. I could use a MAP here
                    default:
                        // Check BG (BG colors start with : e.g. `:red`
                        if (p.indexOf(':') == 0) {
                            let col = p.split(':')[1];
                            if (COLORS_BG.has(col)) {
                                ret += COLORS_BG.get(col);
                            }
                            else {
                                throw new Error(`Tag Error: Color Error ${A}`);
                            }
                        }
                        else {
                            // If not BG, then it must be normal Color
                            if (COLORS_FG.get(p)) {
                                ret += COLORS_FG.get(p);
                            }
                            else {
                                // DEV: Could I throw an error here?
                                // throw new Error(`Tag Error: Color Error ${A}`);
                                ret += A;
                            }
                        }
                } //-- end switch
            } //-- end for
            return ret;
        });
        return str;
    } // -------------------------------------------------------;
} // end class Terminal --
export default new Terminal();
//# sourceMappingURL=Terminal.js.map