
/**
 * Filesystem Tools & Functions 
 *
 */

const FS = require('fs');
const L = require('jlib/Log');
const PATH = require('path');

/**
 * Useful for filenames. Removes the \ / : " * ? < > | characters
 * @param {String} f
 **/
exports.sanitizePath = (f) => f.replace(/[\\/:"*?<>|]/g, '');

/**
 * SYNC Get contents of a file and return them
 * Returns NULL for any error
 * @param {String} f Filename to load
 * @returns {String} File contents
 */
exports.fileGet = (f) =>
{
	let contents;
	try { 
		contents = FS.readFileSync(f, {encoding: "utf8"} ); 
	} catch(e) {
		return null;
	}
	return contents;
}// -------------------------;


/**
 * Add Binary content from SOURCE to DEST file ( DEST will be created )
 * readStart and readLen are for the Source file.
 * @param {String} source Source File
 * @param {String} dest Destination file (will be created)
 * @param {Number} readStart Where in source to start copying
 * @param {Number} readLen How many bytes to copy (0) to copy rest of the file
 * @param {String} destMode Dest file open mode | w:write create, a:append create, wx:w + fail if exists, ax:a + fail if exists
 * @returns {Promise} Errors and Result with some infos
 * @Throws {String} Errors
 */
exports.copyPart = function (source, dest, readStart = 0, readLen = 0, destMode = 'w')
{
	// DEV: I can't just do `async` because I need to be able to call REJECT() from callbacks

	return new Promise((res, rej) => {
	
	let stat; 
	try{ stat = FS.statSync(source); } catch(er){
		throw `Cannot read file '${source}'`; // DEV LEARN: Yes I can throw in the main executor body
	}

	let srcSize = stat.size;

	if (readLen == 0) readLen = srcSize - readStart;
	else if (readLen + readStart > srcSize) {
		throw `Trying to copy more bytes than available in '${source}'`;
	}

	// DEV: it needs the -1 for readEnd because it is inclusive | i.e. (readStart to readStart) would read 1 byte
	// Actual ending position to read
	let readEnd = readStart + readLen - 1;

	// DEV: - Streams will autoclose, even on error
	// 		- Default buffer size is 64KB `highWaterMark`
	let strIn = FS.createReadStream(source, { start: readStart, end: readEnd, flags: 'r' });
		strIn.once('error', er => rej(`Could not read file '${source}'`));

	let strOut = FS.createWriteStream(dest, { flags: destMode });
		strOut.once('error', er => rej(`Could not write file '${dest}'`));

	L.debug(`Copying "${source}" BYTES [(from)::${readStart} (len)::${readLen} (end)::${readEnd}] to "${dest}"`);

	strIn.pipe(strOut);

	strOut.once('close', res);

	});

	/* DEV: Other manual way of doing it, put pipes work just fine.

		let buffer, bytesLeft = readLen;
		while (bytesLeft > 0) {
			let blen = (bytesLeft >= BUFFERSIZE) ? BUFFERSIZE : bytesLeft;
			buffer = strIn.read(blen);
			strOut.write(buffer);
			bytesLeft -= blen;
		}
		strIn.close();
		strOut.close(); */

};// -------------------------------------------------------;


/**
 * Windows does not support file globbing like Bash
 * This is a simple globbing function to get {*.ext} and {*} from a folder
 * Returns Relative Paths, Like BASH
 * @param {String} inp Path to search. e.g. "a:\\*.gif"
 * @return {String[]} List of files found. Only Filenames, NO FULL PATHS, NO DIRS
 * 						Returns [] if error or nothing found
 */
exports.dirGlob0 = function (inp, cwd) {

	cwd = cwd ?? process.cwd();
	let p = PATH.parse(PATH.resolve(inp));
	// console.log(p); // { root: 'c:\\', dir: 'c:\\iso', base: '*.cue', ext: '.cue', name: '*' }
	if (p.name != "*") return [];
	let all;
	try{
		all=FS.readdirSync(p.dir,{withFileTypes:true});
	}catch(e){
		L.error(`dirGlobExt: Could not read "${base}"`);
		return [];
	}
	let out = [];
	all.forEach((f)=>{
		if(f.isFile())
			if(!p.ext || (p.ext && f.name.endsWith(p.ext)))
				out.push(PATH.relative(cwd,PATH.join(p.dir,f.name)));
	});
	return out;
};// -------------------------------------------------------;