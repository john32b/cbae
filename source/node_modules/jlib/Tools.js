
/*
 * General Tool Functions 
 */

const L = require('jlib/Log')


/**
	Deep copies object fields from one object to another object
	Tested for parameter objects
	Note tested for functional objects
	-- Code copied from my HAXE djA Library --
**/
exports.copyFields = (from, into) => {
	if (from == null) return into;
	if (into == null) into = {};

	for (let f in from) {
		if(from[f] instanceof Array) {
			Reflect.set(into,f,[...from[f]]);	// Try to clone the array
		} else if (typeof from[f] == "object") {
			Reflect.set(into, f, exports.copyFields(from[f], into[f])); // Try to Deep copy the branch
		} else {
			Reflect.set(into, f, from[f]); // Expect Literal
		}
	}
	return into;
}// -------------------------;


/** Quickly clamp a number */
exports.clamp = (num, min, max) => Math.min(Math.max(num, min), max);
/** Return a Number between a range  */
exports.randomInt = (from, to) => Math.round(Math.random() * (to - from)) + from;
/** Random Num (float) between a range */
exports.randomNum = (from, to) => from + (from - to) * Math.random();
/** Get Megabytes from Bytes */
exports.bytesToMBStr = (bytes) => '' + Math.ceil( bytes / (1024 * 1024) );

/** Rounds a float to decimals 
 * - Taken from Franco Ponticelli's THX library:
 * - https://github.com/fponticelli/thx/blob/master/src/Floats.hx#L206 
 * e.g. roundFloat(3.477777...,2) => 3.48
 */
 exports.roundFloat = (number, precision=2) => {
	 number *= Math.pow(10, precision);
	 return Math.round(number) / Math.pow(10, precision);
 }//---------------------------------------------------;


/**
 * Create Array.last() to return the last element of an array
 * - DEV: With this way the function is not iterable
 * - DEV: Other way is `Array.prorotype.last = function()....`
 */
Object.defineProperty( Array.prototype, "last", {
	value: function(n=1){
		if (this == null) {
			throw new TypeError('this is null or not defined');
		}
		if (this.length == 0) return undefined;
		if (this.length - n < 0) return this[0];
		return this[this.length - n];
	},
	writable: false,
	enumerable: false, /* this controls for..in visibility */
	configurable: false
}); // -------------------------------------------------------;


/**
 * Create Array.queueRun() 
 * - Calling next() is automatically put on a new event loop tick
 * - You must check for el==null to get when the queue ends
 * - Executes a function for all elements, but only goes to the 
 *   next element with a callback.
 * - WARNING. Modifies self, as it works with shift()
 * - e.g:
 * 	[1,2,3].queueRun( (el, next) => {
 * 		doSomethingWith(el);
 * 		if(el==undefined) queueComplete(); else
 * 		next();
 *	});
 */
Object.defineProperty( Array.prototype, "queueRun", {
	value: function(userFn) {
		const T = this;
		const q = () => {
			let el = T.shift();
			userFn.call(T, el, () => {
				process.nextTick(q);	// Avoid deep stacks, at a speed cost
			});
		};
		q();
	},
	writable:true,
	enumerable:false,
	configurable:true
});


/**
 * Parallel execute Promises with a Max Parallel Limit
 * - If one rejects, it will WAIT for all current running Promises to settle
 *   then Reject as a whole with a {String[]} holding errors from any rejected
 * ^ This is for safety. i.e. Don't report to user while a Promise is still doing 
 *   something in the background that could be destructive. Like still creating files
 *   as user would want to do some cleanup.
 * @param {Function<Promise>} Generator Function that provides promises
 * @param {Number} max Maximum number of Promises to run in parallel
 * @param {Function<Number>} Callback after each Promise Completes/Fails -- Use for progress tracking
 * @return {Promise} 
 * @throws {String[]} Errors are in the order they occured. Usually read the first one
 *  Example:
 * 	PromiseRun(myGenerator() , 2 ).then( ()=>{ all complete } ).catch( er => {...} );
 */
exports.PromiseRun = (pgen, pmax = 4, pcb) => new Promise((res, rej)=>{

	let RUNNING = 0;
	let COMPLETE = 0;
	let ERRORS = null;	// {String[]} Hold all Errors from Promises to return when all settled

	function tryAdd()
	{
		// Do not start a new Promise, wait for the current ones to end
		if(ERRORS)
		{
			if(RUNNING==0) {
				L.error(`PromiseRun -- END WITH ERRORS (${ERRORS.length}) -- Run (${COMPLETE})`);
				return rej(ERRORS);
			}
			
			return; // has more promises that are running. wait
		}

		let gen = pgen.next(); // Start a new promise
				
		if(gen.done)
		{
			if(RUNNING==0) {
				L.log(`PromiseRun -- END -- ALL (${COMPLETE}) SETTLED`);
				return res();
			}
			// There are no more Promises to get, but some Promises are still running. wait
			return;
		}

		RUNNING++;
		gen.value
		.catch(er=>{
			if(!ERRORS) ERRORS = [];
			if(er instanceof Error) {
				ERRORS.push(er.message);
			}else{
				ERRORS.push(er);	// Either {String} or {Any}
			}	
		})
		.finally( ()=>{
			COMPLETE++;
			RUNNING--;
			L.debug(`PromiseRun -- Completed (${COMPLETE}) `);
			if(typeof pcb == 'function') pcb(COMPLETE);
			tryAdd();
		});

	}// -------------------------;

	// -- Start running promises
	L.log(`PromiseRun -- START -- Max parallel (${pmax})`);
	while (pmax--) tryAdd();

	// DEV: I don't need to track Max, because when a Promise ends another takes its place
	//		one Promise spawns one. So it can never exceed {pmax}
	
});// -------------------------------------------------------;
