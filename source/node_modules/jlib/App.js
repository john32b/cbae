/**
 * Handle Program Arguments
 * - Makes it easy to declare/manage inputs/outputs/actions
 * - Prints Banner and Help Screen
 * ------------------
 * Default Export : BaseApp Object
 * import APP from 'jlib/Baseapp'	// suggestion
 *
 ************************************************************/
import * as PATH from 'node:path';
import T from './Terminal.js';
import L from './util/Log.js';
import * as TFS from './util/FsTools.js';
import { copyFields } from './util/Tools.js';
/* In help, how long the - lines will be */
const LINE_LEN = 40;
// Initial Program Properties/Parameters
var IP = {
    /** Program Name. Printed on banner */
    name: 'app',
    /** Program Version. Printed on banner */
    ver: '0.1',
    /** Program Description. Printed on -help */
    desc: '',
    /** REQUIRE action to run,  Program will exit error. */
    act: false,
    /** Set available ACTIONS
     *  {actionTag : Description<string>}
     *  	e.g  {c : "Compress Input File"}
     * 	- Add newlines with <|>
     *  - If Description starts with ! it will be the default action if none set
     *  - If Description starts with - it will not be shown in help
     **/
    actions: {},
    /** Set available OPTIONS
     * 	{ optionName :   Description<String> }
     *  { optionName : [ Description<String> , ?requiresParams<String>, ?defaultValue<String>(for docs only) ] }
     *  e.g  {p : [ "Set parallel workers", "yes", "3" ]}
     * - DO NOT USE 'o' as option as it is used internaly
     * - If description starts with - it will not be shown in help
     * - Add newlines with <|>
     */
    options: {
        o: ["-", "y"],
        log: ['-', 'y'] // LEVEL=FILE | e.g. 4=/tmp/log.txt | Declare log level and file | You can skip level
        // DEV NOTE: everytime you add a built in option. Goto printHelp() and adjust {BUILT_IN_OPTIONS}
    },
    /** Custom HELP text, displayed with -help */
    help: {
        /** Text under the banner */
        info: null,
        /** Text at the usage screen. Supports TAGS | Reminder <n> newline <t> tab */
        usage: null,
        /** Text at the end of the -help screen. Supports TAGS */
        post: null,
        /** Show help when program is run without any arguments */
        noarg: false,
        /** How to describe input/output usage in help
         * i : input | I : inputs | o : output */
        io: "Io",
    }
};
/**
 * The main Program APP object
 */
export default {
    // Initial Parameters
    // User can override and add new by passing override fields in APP.init();
    action: null,
    option: {},
    input: [],
    output: null,
    executable: PATH.basename(process.argv[1]),
    // :: --------------------------------------
    infos() { return IP; },
    /**
     * Read and parse the arguments
     * @return Error:String if any error. or <null> for Success
     */
    _readArguments() {
        let cc = 2; // start from argv[2] which is the first argument
        let arg = ""; // Hold current argument for the loop
        if (process.argv.length == 2 && IP.help.noarg)
            return "HELP";
        while ((arg = process.argv[cc++]) != null) {
            // Argument is <OPTION>
            if (arg.charAt(0) === "-") {
                arg = arg.slice(1); // remove first -
                if (arg == "help" || arg == "-help")
                    return "HELP"; // Force of habit to write --help
                let o = IP.options[arg];
                if (!o)
                    return `Illegal Option <red>-${arg}<!>`;
                if (typeof (o) == "object" && o[1] != null) // Requires a parameter | could also do Array.isArray()
                 {
                    let nextArg = process.argv[cc++];
                    if (!nextArg)
                        return `Option <yellow>-${arg}<!> requires a parameter`;
                    this.option[arg] = nextArg;
                }
                else {
                    this.option[arg] = "1";
                }
                continue;
            }
            // Argument is <ACTION>
            // allows other action names to be passed as inputs
            if (IP.actions[arg] && !this.action) {
                this.action = arg;
                continue;
            }
            // Argument must be <INPUT>
            // It is not action or option, so it must be an input
            this.input.push(arg);
        } //-- end parsing arguments -- ;
        this.output = this.option.o; // No guard, can be null
        delete this.option.o;
        // If no action was given, make the action starting with "!" as default
        if (!this.action)
            for (let i in IP.actions)
                if (IP.actions[i].charAt(0) == "!")
                    this.action = i;
        if (IP.act && !this.action)
            return `Action is required`;
        if (this.input[0]?.includes('*')) {
            let glob = TFS.dirGlob0(this.input[0]);
            T.pac(` > glob returned ${glob.length} files\n`);
            this.input.splice(0, 1, ...glob); // <- add all new files in place of the first element
        }
        // - Make options that were not set, to false
        for (let [k, v] of Object.entries(IP.options)) {
            if (typeof v == "string" || v[1] == null) {
                // option not expecting argument
                if (!(k in this.option)) {
                    this.option[k] = "";
                }
            }
        }
        return null;
    },
    /**
     * Initialize. Get and process the program launch arguments
     * will EXIT(1) if there are argument errors
     * After this, the APP fields {action,option,input,option} will be ready\
     * @param userParams Override fields of APP.IP
     */
    init(userParams) {
        // DEV: I could do 
        // userParams:Partial<typeof IP> = {})
        T.reset(); // Just in case
        IP = copyFields(userParams, IP);
        /* DEV: Some common exit codes :
            0:Success | 1:Generic Error | 1223: User Cancel */
        // Because when CTRL+C the 'onexit' handler is not called. So make it.
        process.once("SIGINT", () => process.exit(1223));
        // -- Handle application exit. Error exit or Normal exit go here
        // TIP: User add custom exit handlers with `process.prependListener(exit...)`
        process.once('exit', (code) => {
            L.log(`==> [EXIT] with code ${code}`);
            T.reset().setCur(true);
        });
        L.log(`Creating App [ ${IP.name} ,v${IP.ver} ]`);
        // - Parse Arguments
        var er = this._readArguments();
        if (er != null) {
            if (er == "HELP") {
                this.printHelp();
                process.exit(0);
            }
            this.printBanner();
            this.panic(er, true);
        }
        // - AutoLog
        let l = this.option.log;
        if (l)
            L.set({
                file: l.split('=').pop(),
                level: parseInt(l[0]) // can be NaN
            });
        L.log('- Inputs :', this.input);
        L.log('- Output :', this.output);
        L.log('- Action :', this.action);
        L.log('- Options :', this.option);
        L.log('-'.repeat(30));
    },
    /**
     * @param longer Print longer banner with full infos
     */
    printBanner(longer = false) {
        let col = "cyan";
        T.ptag(`\n<:${col},black>==<!><${col},bold> ${IP.name} <darkgreen>v${IP.ver}<!>`);
        T.ptag(` <it,darkgray>${IP.desc ?? ''}<!,n>`); // Next to the title
        if (longer && IP.help.info) {
            T.ptag(IP.help.info).n();
        }
        T.fg('darkgray').println('-'.repeat(LINE_LEN)).reset();
    },
    /**
     * Shows Basic program usage
     * Autogenerated based on `params` object
     */
    printHelp() {
        this.printBanner(true);
        const MARGIN = 12; // Action/Option Help Margin, in spaces
        let sp = (s) => " ".repeat(s); // Quick create blank space
        let has_a = Object.keys(IP.actions).length > 0; // Has Actions
        let has_o = Object.keys(IP.options).length > 2; // Has Options (2 are the (o,log fields) {BUILT_IN_OPTIONS}
        /* Fix format of action/option text.
         * Add padding, convert <|>, optional text at first line */
        let conv = (a, opt = '') => {
            let l = a.split('<|>');
            l[0] += opt;
            return l.join(T.EOL + sp(MARGIN));
        };
        // -- Program usage --
        T.ptag('<cyan> Program Usage:').n();
        let s = '   ' + this.executable + ' '; // Building a string to print
        if (has_a)
            s += "<action> ";
        if (has_o)
            s += "[<options>...] ";
        let _qio = IP.help.io.includes.bind(IP.help.io); // Shorthand
        if (_qio('I'))
            s += "[<inputs>...] ";
        else if (_qio('i'))
            s += "<input> ";
        if (_qio('o'))
            s += "-o <output> ";
        T.ptag(`<bold,white>${s}<!,n>`);
        // -- Print Input/Output Help --
        if (IP.help.usage)
            T.ptag(IP.help.usage).n();
        T.fg('darkgray').println('-'.repeat(LINE_LEN));
        // -- Print <actions> --
        if (has_a) {
            T.ptag('<cyan> <actions> <darkgray,it>(you can set one action at a time)<!,n>');
            for (let k in IP.actions) {
                let def = '';
                let str = IP.actions[k];
                if (str.charAt(0) == "-")
                    continue;
                if (str.charAt(0) == "!") {
                    str = str.slice(1);
                    def = ' <darkcyan,it>(default action)<!>';
                }
                T.ptag('<white,bold> ' + k + '<!,gray>' +
                    sp(MARGIN - k.length - 1) + conv(str, def)).n();
            }
        }
        // -- Print <options> --
        if (has_o) {
            T.ptag('<cyan> <options> <darkgray,it>(you can set multiple options)<!,n>');
            for (let k in IP.options) {
                // HACK: Force cast because TypeScript is dumb >>
                let str = (typeof IP.options[k] == "string" ? IP.options[k] : IP.options[k][0]);
                if (str.charAt(0) == "-")
                    continue;
                let opt = IP.options[k][1] ? " <darkcyan,it>(requires parameter)<!> " +
                    (IP.options[k][2] ? `<darkgray,it>default(${IP.options[k][2]})<!>` : "") : "";
                T.ptag('<white,bold> -' + k + '<!,gray>' +
                    sp(MARGIN - k.length - 2) + conv(str, opt)).n();
            }
        }
        if (IP.help.post) {
            T.fg('darkgray').println('-'.repeat(LINE_LEN)).reset();
            T.ptag(IP.help.post).n();
        }
    },
    /**
     * Exit Program Execution **NOW**
     * @param err The error message. Supports ptags
     * @param promptHelp If true will print (-h for help)
     */
    panic(err, promptHelp) {
        T.ptag(`<:darkred,white> ERROR <!> ${err}<!,n>`);
        if (promptHelp === true) {
            T.ptag('<darkgray>' + '-'.repeat(LINE_LEN)).n();
            T.ptag('<yellow> -help <!> for usage info').n();
        }
        L.error('APP: EXIT ERROR : ' + T.st(err));
        process.exit(1); // With generic error code
    },
    /**
     * Assert that proper INPUTS/OUTPUTS have been declared.
     * If not Exits Error
     * Just put all the tags in a single string. e.g. "imo"
     * #### TAGS
     *  `i` : Requires Input
     *  `m` : Optionally support Multi Inputs.
     *  `o` : Requires Output
     * #### TODO
     *  f : Input(s) must be a valid file -- will check --
     *  d : Input must be a directory -- will check --
     */
    assertIO(tag = "io") {
        let t = {}, $ = this.input;
        for (let i of tag)
            t[i] = true;
        try {
            if (t.i) {
                if ($.length == 0)
                    throw "Requires Input";
                if ($.length > 1 && !t.m)
                    throw "Multiple Inputs not supported";
            }
            if (t.o) {
                if (!this.output)
                    throw "Requires Output";
            }
        }
        catch (e) {
            this.panic(e);
        }
    } // -------------------------;
};
//# sourceMappingURL=App.js.map