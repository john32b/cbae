
const L = require('jlib/Log')
const T = require('jlib/Terminal')
const {copyFields} = require('jlib/Tools');
const PATH = require('path')
const TFS = require('jlib/FsTools');

/* In help, how long the - lines will be */
const LINE_LEN=40;

// :: ----------------------------------------------------;

var APP = {

	// Init Parameters
	// You can override and add new by passing override fields in APP.init();
	IP : {

		// Basic Infos
		name:'app',
		ver:'0.1',
		desc:null,		// String
		
		// -----------------

		// Set program Actions here
		// 		> { actionTag : "ActionDescription" } | example { c : "Compress input file"}
		// - Add newlines with <|>
		// - If Description starts with ! it will be the default action if none set
		// - If description starts with - it will not be shown in help 
		actions: {},

		// Set program Options here {String[]} or {String}
		//  	> description:String : { ?requiresParams:String (any value for yes), ?defaultValue:String (for docs only) }
		//  	> "description" <- you can also do this when you don't require parameters
		//  	> example | p : ["Set parallel workers","yes","3"]
		// - DO NOT USE {o} as option as it is used internaly 
		// - If description starts with - it will not be shown in help 
		// - Add newlines with <|>
		options: {
			o: ["-", "y"],		// This is used internally to get output path
			log:['-','y']		// LEVEL=FILE | e.g. 4=/tmp/log.txt | Declare log level and file | You can skip level

			// DEV NOTE: everytime you add a built in option. Goto printHelp() and adjust {BUILT_IN_OPTIONS}
		},

		require:{
			action:false,	// Error out if there is no Action set ( with default action considered )
			input:"no",		// {yes, no, Actionid (csv)} Require Input | yes: for all actions | no: | 
							// 	| Action ID (csv) for some actions , e.g. "enc,dec" = 
			output:"no",	// ~> same as above 
			multi:true,		// Supports miltiple inputs | Basic globbing {*} {*.ext} | Changes usage string in -help
		},

		help: {
			info:null,				// String[], Text under the banner
			usage:null,				// Text at the usage screen. Supports TAGS. For new lines do <t> for tabs
									// e.g. "<magenta>input:<!> .cue files only<n,t,magenta>output:<!> folder to extract",
			post:null,				// Text at the end of the -help screen. Supports TAGS
			ehelp:false,			// If program is run without any arguments, Show Help
		}

	},// ---------------------;


	// These variables are set on init(); You can read them.
	action: null,	// The action TAG name that is set | e.g. "c"
	option: {},		// All the options + parameters that are set | [ {option:param}... ]
	input: [],		// All the input files | 
	output: null,	// Output file/path that was set
	executable: PATH.basename(process.argv[1]),	// Name of the script e.g. "cdcrush"
	// :: --------------------------------------

	/**
	 * Read and parse the arguments
	 * @return Error:String if any error. or <null> for Success
	 */
	_readArguments() 
	{
		let P = this.IP; // write less
		let cc = 2; // start from argv[2] which is the first argument
		let arg = ""; // Hold current argument for the loop

		if(process.argv.length==2 & this.IP.help.ehelp) return "HELP";

		while ((arg = process.argv[cc++]) != null) 
		{
			// Argument is <OPTION>
			if (arg.charAt(0) === "-") {
				arg = arg.slice(1);	// remove first -
				if (arg == "help") return "HELP"; // 
				let o = P.options[arg];
				if (!o) return `Illegal Option <red>-${arg}<!>`;
				if (typeof (o) == "object" && o[1] != null)	// Requires a parameter | could also do Array.isArray()
				{
					let nextArg = process.argv[cc++];
					if (!nextArg) return `Option <yellow>-${arg}<!> requires a parameter`;
					this.option[arg] = nextArg;
				} else {
					this.option[arg] = true;
				}
				continue;
			}

			// Argument is <ACTION>
			if (P.actions[arg] && !this.action)
			{
				// Just in case, allow other action names to be passed as inputs
				this.action = arg;
				continue;
			}

			// Argument must be <INPUT>
			// It is not action or option, so it must be an input
			this.input.push(arg);

		}//-- end parsing arguments -- ;


		this.output = this.option.o;	// No guard, can be null
		delete this.option.o;

		// If no action was giver, make the action starting with "!" as default
		if (!this.action)
			for(let i in P.actions) 
				if(typeof P.actions[i] == 'string' && P.actions[i].charAt(0)=="!") this.action=i;

		if (P.require.action && !this.action)
			return `Action is required`;

		let check = (s)=>{
			if(s=="yes") return true;
			if(s=="no") return false;
			return s.split(',').some( v => v==this.action );
		}

		// - Check Inputs / Outputs / Actions
		if (this.input.length == 0 && check(P.require.input))
			return `Input is required`;

		if (!this.output && check(P.require.output))
			return `Output is required`;

		if (this.input.length > 1 && !P.require.multi)
			return `Multiple inputs not supported`;

		if(this.input[0].includes('*'))
		{
			if(!P.require.multi) return `Wildwards * not supported.`
			this.input = TFS.dirGlob0(this.input[0]);
		}

		// DEV: No wildcards, the OS should provide a list of files
		// TODO: autoget action based on Filename ? >> NO

		// - Make options that were not set to Boolean false
		for (let [k, v] of Object.entries(P.options)) {
			if (typeof v=="string" || v[1] == null) {
				// option not expecting argument
				if (!(k in this.option)) {
					this.option[k] = false;
				}
			}
		}

		return null;
	},//-----------------------------------;



	/**
	 * Initialize. Gets and processes the arguments
	 * will EXIT(1) if there are argument errors
	 * After, the global fields {action,option,input,option} will be ready
	 * @param {Object:params} Override <this.param> fields.
	 */
	init(userParams) 
	{
		T.reset(); // Just in case
		
		this.IP = copyFields(userParams, this.IP);

		/* DEV: Some common exit codes : 
			0:Success | 1:Generic Error | 1223: User Cancel */

		// Because when CTRL+C the 'onexit' handler is not called. So make it.
		process.once("SIGINT", ()=> process.exit(1223) );

		// -- Handle application exit. Error exit or Normal exit go here
		// TIP: User add custom exit handlers with `process.prependListener(exit...)`
		process.once('exit', (code)=>{
			L.log(`==> [EXIT] with code ${code}`);
			T.reset().setCur(true);
		});
		

		L.log(`Creating App [ ${this.IP.name} ,v${this.IP.ver} ]`);		

		// - Parse Arguments
		var er = this._readArguments();
		if (er != null) {
			if(er=="HELP") {
				this.printHelp();
				process.exit(0);
			}
			this.printBanner();
			this.exitError(er, true);
		}

		// - AutoLog
		let l = this.option.log;
		if(l) 
			L.set({
				file:l.split('=').pop(),	// can be undefined
				level:parseInt(l[0])		// can be NaN
			});

		L.log('- Inputs :', this.input);
		L.log('- Output :', this.output);
		L.log('- Action :', this.action);
		L.log('- Options :', this.option);
		L.log('-'.repeat(30));

	},//-----------------------------------;


	/**
	 * @param {Boolean} longer Print longer banner with full infos
	 */
	printBanner(longer) 
	{
		let col="cyan";
		let P = this.IP;	// shorter code
		T.n();
		T.ptag(`<:${col},black>==<!><${col},bold> ${P.name} <darkgreen>v${P.ver}<!>`);
		T.ptag(` <it,darkgray>${P.desc??''}<!,n>`);	// Next to the title
		if(longer && P.help.info) {
			T.ptag(P.help.info).n();
		}
		T.fg('darkgray').println('-'.repeat(LINE_LEN)).reset();
	},//-----------------------------------;

	/**
	 * Shows Basic program usage
	 * Autogenerated based on `params` object
	 */
	printHelp()
	{
		this.printBanner(true);
		const BUILT_IN_OPTIONS = 2;
		let MARGIN = 12;		// Action/Option Help Margin, in spaces
		
		let P = this.IP;
		
		let sp = (s) => " ".repeat(s); // Quick create blank space
		let has_a = Object.keys(P.actions).length > 0;	// Has Actions
		let has_o = Object.keys(P.options).length > BUILT_IN_OPTIONS;  // Has Options
		
		/* Fix format of action/option text. 
		 * Add padding, convert <|>, optional text at first line */
		let conv = (a, opt='') => {
			let l = a.split('<|>');
			l[0] += opt;
			return l.join(T._NL + sp(MARGIN));
		}

		// -- Program usage --
		T.ptag('<cyan> Program Usage:').n();
		let s = '   ' + this.executable + ' '; // Building a string to print
		if (has_a) s += "<action> ";
		if (has_o) s += "[<options>...] ";
		if (P.require.input != 'no') s += P.require.multi ? "[<inputs>...] " : "<input> ";
		if (P.require.output != 'no') s += "-o <output> ";
		T.ptag(`<bold,white>${s}<!,n>`);

		// -- Print Input/Output Help --
		if(P.help.usage) T.ptag(P.help.usage).n();
		T.fg('darkgray').println('-'.repeat(LINE_LEN));

		// -- Print <actions> --
		if (has_a) {
			T.ptag('<cyan> <actions> <darkgray,it>(you can set one action at a time)<!,n>');
			for (let k in P.actions) {
				let def='';
				let str = P.actions[k];
				if (str.charAt(0) == "-") continue;
				if (str.charAt(0) == "!") { str = str.slice(1); def = ' <darkcyan,it>(default action)<!>'; }
				T.ptag('<white,bold> ' + k + '<!,gray>' + 
					sp(MARGIN - k.length - 1) + conv(str, def)).n();
			}
		}

		// -- Print <options> --
		if (has_o) {
			T.ptag('<cyan> <options> <darkgray,it>(you can set multiple options)<!,n>');
			for (let k in P.options) {
				// field could be string or array
				let str = typeof P.options[k] == "object" ? P.options[k][0] : P.options[k];
				if (str.charAt(0) == "-") continue;
				let opt = P.options[k][1] ? " <darkcyan,it>(requires parameter)<!> " + 
					(P.options[k][2]?`<darkgray,it>default(${P.options[k][2]})<!>`:""):"";
				T.ptag('<white,bold> -' + k + '<!,gray>' + 
					sp(MARGIN - k.length - 2) + conv(str, opt)).n();
			}
		}

		if(P.help.post) {
			T.fg('darkgray').println('-'.repeat(LINE_LEN)).reset();
			T.ptag(P.help.post).n();
		}

	},//-----------------------------------;

	/**
	 * Exit Program Execution NOW
	 * @param {String} err The error message. Supports ptags
	 * @param {Boolean} promptHelp If true will print (-h for help)
	 */
	exitError(err, promptHelp = false)
	{
		T.ptag(`<:darkred,white> ERROR <!> ${err}<!,n>`);
		if(promptHelp) {
			T.ptag('<darkgray>' + '-'.repeat(LINE_LEN)).n();
			T.ptag('<yellow> -help <!> for usage info').n();
		}
		L.error('APP: EXIT ERROR : ' + T.st(err) );
		process.exit(1);	// With generic error code
	},//-----------------------------------;

};


// -------------------------------------------------------;

module.exports = APP;