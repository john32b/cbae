/**
 * @callback cb_string
 * @param {String} param
 * @returns {undefined}
 * 
 * @callback cb_int
 * @param {Number} param
 * @returns {undefined}
 * 
 * ---------------------------------
 * 
 * HELP -- https://nodejs.org/api/child_process.html#child_processspawncommand-args-options 
 * 
 * DEV TIPS:
 * ---------
 * 	-	You can access proc.stdio right after startP. The Promise runs in the same loop
 *		It is the promise handlers that are async
 * 
 *  -	When you access the {stdin} make sure you add an error handler
 * 		even an empty one will do | proc.stdin.once('error',()=>{});
 * 		Without it, the main process error event cannot fire
 * 		'new' use the stdin getter
 * 
 ************************************************************************/


const { spawn, ChildProcess, execSync } = require('child_process');
const L = require('jlib/Log');


/** Give each process a unique number to keep track in debug  */
// var ID = 0;

/**
 * Proc2 - Process (2) , A level above ChildProcess -- thus the 2
 * 
 * - This is just a handy wrapper with boilerplate for spawning processes
 * - Setting onErr,onOut will enable realtime callbacks
 * - logExit is offered when the process exits
 * - log is offered and is built at realtime
 * - Listen to onClose(.) or use startP to get a Promise
 * - You can access stdin normally and pipe to it
 * 
 */
module.exports = class Proc2 {

	static ID = 0;
	/** @type {String} 
	 * Executable string e.g. "ffmpeg" */
	exec;

	/** @type {String} 
	 * Current working Dir */
	cwd;

	/** @type {ChildProcess} */
	proc;

	/** @type {cb_int}
	 *  Once the App closes (success/fail) will call this one
	 *  Parameter is the Exit Code, 0 for Success. You can read logExit for more */
	onClose;

	/** @type {{err:String, out:String, code:Number}}
	 * Automatically written when the process exits */
	logExit = { err: '', out: '', code:0 };

	/** @type {{err:String, out:String}}
	 * If set, stdout/err will write to it as it gets data
	 * DEV: Automatically sets the stream encoding to UTF-8, should be fine 
	 * DEV: This could be redundant or Rare? since I have {logExit} */
	log;

	/** @type {cb_string}
	 *  If set will callback stdErr in Realtime */
	onErr;

	/** @type {cb_string}
	 *  If set will callback stdOut in Realtime */
	onOut;

	/**
	 * Initialize with vars
	 * exec : Executable to run
	 * P.cwd  : Current Working Dir
	 * P.log : stderr/log Object
	 * P.onClose : End Callback
	 * P.onErr : realtime stdErr callback
	 * P.onOut : realtime stdOut callback
	 */
	constructor(exec, P) {
		this.id = ++Proc2.ID;
		this.exec = exec;
		this.cwd = P?.cwd;
		this.onClose = P?.onClose;
		this.log = P?.log;
		this.onErr = P?.onErr;
		this.onOut = P?.onOut;
	}// -------------------------;


	/**
	 * Return the process STDIN for writing
	 * Do this after startP or start
	 * @returns {WritableStream}
	 */
	get stdin() {
		// If I don't add this and an error occurs, it will not send the error event to the process
		this.proc.stdin.once('error', () => { });
		return this.proc.stdin;
	}// -------------------------;

	/** Promise Start, It returns a promise, 
	 * - DEV: It calls the already set onClose before resolving
	 * @param {String[]|String} args Normal Array of Strings, or String with `|` separated
	 */
	startP(args) {
		return new Promise((res, rej) => {
			this.onClose = (c) => {
				if (c == 0) return res();
				rej(this.logExit);	// Push the whole thing, let the user decide what to do with it
			}
			this.start(args);
		});
	}// -------------------------;


	/**
	 * Start the process using arguments. NodeJS likes arguments in an Array, but you
	 * can pass arguments in a single String. Be careful with that, separate args with `|`
	 * @param {String[]|String} args Normal Array of Strings, or String with `|` separated
	 */
	start(args) {
		if (typeof (args) == 'string') args = args.split('|');

		L.log(`AppRun (${this.id}): ${this.exec} ${args ? args.join(' ') : ''} | cwd:${this.cwd ?? process.cwd()}`);

		let p = this.proc = spawn(this.exec, args, { cwd: this.cwd });
		
		
		/*  The 'error' event is emitted whenever: 
		* - The process could not be spawned, or
		* - The process could not be killed, or
		* - Sending a message to the child process failed.
		*/
		p.once('error', er => {
			let el = this.logExit;
			L.error(`AppRun (${this.id}): ERROR ${er.message}`);
			if(er.message.endsWith('ENOENT')) {
				el.err = `Cannot execute "${this.exec}"`;
				el.code = 2; // 2:ENOENT: No such file or directory
				return;
			}
			el.err = er.message;
			el.code = 1;
		});


		/* The 'exit' event is emitted after the child process ends.
		* When the 'exit' event is triggered, child process stdio streams might still be open.
		* This is why I am getting the final stdout.err here
		* DEV: highWaterMark is 16KB, I don't know how to lower it
		* DEV: triggers before 'close' event
		*/
		p.once('exit', (code, killsig) => {

			let _e = p.stderr.read();
			let _o = p.stdout.read();

			this.logExit = {
				err: _e ? Buffer.from(_e).toString() : '',
				out: _o ? Buffer.from(_o).toString() : ''
			}
		});


		/* The 'close' event is emitted when the stdio streams of a child process have been closed. 
		* DEV It is safer than 'exit' since 'exit' could emmit while stdio streams are open
		* 	Triggers after 'exit' event
		* 	Error event -> Close event	
		*/
		p.once('close', (code, killsig) => {

			this.kill();	// Help the GC ?
			let el = this.logExit;

			if (code == 0) {
				L.log(`AppRun (${this.id}): CLOSE - OK`);
				return this.onClose(0);
			}

			// In case 'onError' was called. Keep the custom code
			if (el.code > 0) 
				code = el.code; 
			else 
				el.code = code;

			// This is normal process exit with some Error Code
			// DEV: 128 from the end should be enough for a quick glance of the error
			L.error(`AppRun (${this.id}): CLOSE - Error Code : ${code}\n` +
				`\tstdErr : ...${el.err.slice(-128)}` +
				`\tstdOut : ...${el.out.slice(-128)}`);
				
			return this.onClose(code);
		});


		// DEV: setEncoding("utf8") makes the chunks on "data" event Strings, 
		//		else they would be buffers

		if (this.onErr) {
			p.stderr.setEncoding("utf8");
			p.stderr.on("data", this.onErr);
		}

		if (this.onOut) {
			p.stdout.setEncoding("utf8");
			p.stdout.on("data", this.onOut);
		}

		// -- Log everything here if an object is set
		if (this.log) {
			this.log.err = this.log.out = "";
			p.stderr.setEncoding("utf8");
			p.stderr.on('data', d => this.log.err += d);
			p.stdout.setEncoding("utf8");
			p.stdout.on('data', d => this.log.out += d);
		}

	}// -------------------------;

	kill() {
		if (this.proc) {
			this.proc.removeAllListeners(); // Don't callback 'close' event when I force close a process
			this.proc.kill();	// DEV:TODO: I could send a specific signal | https://man7.org/linux/man-pages/man7/signal.7.html
			this.proc = null;
		}
	}// -------------------------;


	/**
	 * Tries to run an executable to see if it exists
	 * @returns {Boolean}  
	 **/
	static checkRun(comm)
	{
		try{
		execSync(comm, { timeout: 5000, stdio: 'ignore' });
		}catch(e){return false;}
		return true;
	}// -------------------------;

}

