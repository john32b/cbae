/**
 * Terminal Related Generic Tools
 */

 const T = require('jlib/Terminal');


/**
 * Generic Progress Counter
 * - Saves Cursor position
 * - Updates a decorative string on a timer
 * - Can show task progress in the form of (1/12)
 * - Prints : "(1/12) ....... "
 * 
 * ------
 * example:
 * 
 * 	Prog.start(10);	// 10 max tasks 
 *  Prog.setTask(5,10);	// CAll this whenever you want. i.e. when a promise ends.
 *  Prog.stop();	// Stops the timer. RETURNS cursor to the end of the line.
 * 
 */
exports.Prog = {

	active:false,
	tick:250,			// Update roller every this
	timer:undefined,	// Interval Timer
	t_max:0,			// Max sub-tasks for the (1/12) string
	t_comp:0,			// Completed sub-tasks for the (1/12) string
	t_str:"",	// The last sub-tasks string printed. e.g. "(1/12) " 
	c:1,		// generic counter for the dots
	cmax:7,		// limit counter for the dots

	/**
	 * Call this right when you want the Progress to start on the CLI
	 * Depending on max=0 or not, the (1/12) string will be written
	 */
	start(max=0)
	{
		T.saveCur();
		if(max>0) this.setTask(0,max);	// Start off with 0 tasks completed.
		this.active = true;
		this.timer = setInterval(this.upd.bind(this), this.tick);	
		// DEV ^ : SetInterval callback changes "this" so using bind gives it back to this
	},

	// DEV: 
	// The Final display string consists of two (2) parts
	// 		Part 1, task progress : "(1/12) "
	// 		Part 2, decorative : " ....... "
	// - Part 2 updates more frequently than part 1 on a timer
	// - Part 1 updates on user call
	// ===> This is why I decided to have two (2) update/print functions
	// upd1() -> updates the pre string "(1/12) " and prints that on screen
	// upd2() -> Only updates the decorative string "...."
	//

	setTask(a,b) // upd1
	{
		// Clear the previous "(1/23) " line and print on top of it
		// > Warning the line could expand by a few characters
		//   but upd2() compensates by printing next to it and erasing the line
		T.restCur().print(' '.repeat(this.t_str.length)).restCur();
		T.pac(this.t_str = `(${a}\/${b}) `);
	},

	upd() // upd2
	{
		T.restCur();
		if(this.t_str) { // move past the (1/12) string
			T.moveR(this.t_str.length, 0);
		}
		T.clearLine(1).print('.'.repeat(this.c));
		if(++this.c>this.cmax) this.c=1;
	},

	/** Restore Cursor and delete string */
	stop()
	{
		if(!this.active) return false;
		clearInterval(this.timer);
		T.restCur().clearLine(1);
		this.active = false;
		return true;
	}
}// -------------------------------------------------------;


