/*
 * General Purpose Tool Functions
 */
import L from './Log.js';
/**
 * From an object with String Fields, Converts chosen fields to Numbers
 * ! Works with ARRAYS in fields
 * @param obj The object to convert
 * @param fields CSV List of field names to convert to numbers
 * example { id:"123", fee:"200" } , "id,fee" --> {id:123, fee:200}
 * object fields "manager.fee,manager.age" or "id,item.*" use .*
 * [TESTS]
 * 	- works for arrays with holes,null,undefined
 *  - Objects works recursively
 **/
export function objectParseNumbers(obj, fields) {
    let o = {};
    let f = fields.split(',');
    for (let [k, v] of Object.entries(obj)) {
        if (v instanceof Object && !Array.isArray(v)) {
            // Hold ALL fields of key (if declared)
            let a1 = [];
            for (let i of f) {
                if (i.indexOf(k) == 0) {
                    a1.push(i.slice(i.indexOf('.') + 1));
                    // a1 now has [price,age] originals:[item.price,item.age]
                }
            }
            // Recurse this function
            if (a1.length > 0) {
                o[k] = objectParseNumbers(v, a1.join(','));
                continue;
            }
        }
        else if (f.includes(k) || f[0] == "*") {
            if (Array.isArray(v)) {
                o[k] = [];
                for (let i in v) {
                    if (typeof (v[i]) == "string")
                        o[k][i] = parseFloat(v[i]);
                    else
                        o[k][i] = structuredClone(v[i]);
                }
                continue;
            }
            if (typeof (v) == "string") {
                o[k] = parseFloat(v);
                continue;
            }
        }
        // works for anything
        o[k] = structuredClone(v);
    }
    return o;
} // -------------------------;
/**
 * Deep copies object fields from one object to another object
 */
export function copyFields(from, into) {
    if (from == null)
        return into;
    if (into == null)
        into = {};
    for (let f in from) {
        if (from[f] instanceof Array) {
            Reflect.set(into, f, [...from[f]]); // Try to clone the array
        }
        else if (typeof from[f] == "object") {
            Reflect.set(into, f, copyFields(from[f], into[f])); // Try to Deep copy the branch
        }
        else {
            Reflect.set(into, f, from[f]); // Expect Literal
        }
    }
    return into;
} // -------------------------;
/** Quickly clamp a number */
export var clamp = (num, min, max) => Math.min(Math.max(num, min), max);
/** Return a Number between a range  */
export var randomInt = (from, to) => Math.round(Math.random() * (to - from)) + from;
/** Random Num (float) between a range */
export var randomNum = (from, to) => from + (from - to) * Math.random();
/** Get Megabytes from Bytes */
export var bytesToMBStr = (bytes) => '' + Math.ceil(bytes / (1024 * 1024));
/** Rounds a float to decimals
 *  Taken from Franco Ponticelli's THX library:
 *  https://github.com/fponticelli/thx/blob/master/src/Floats.hx#L206
 *  e.g. roundFloat(3.477777...,2) => 3.48
 */
export var roundFloat = (number, precision = 2) => {
    number *= Math.pow(10, precision);
    return Math.round(number) / Math.pow(10, precision);
}; // -------------------------;
/**
 * Parallel execute Promises with a Max Parallel Limit
 * - If one rejects, it will WAIT for all current running Promises to settle
 *   then Reject as a whole with a {String[]} holding errors from any rejected
 * ^ This is for safety. i.e. Don't report to user while a Promise is still doing
 *   something in the background that could be destructive. Like still creating files
 *   as user would want to do some cleanup.
 * @param pgen Generator Function that provides promises | The called part, generator()
 * @param pmax Maximum number of Promises to run in parallel
 * @param pcb Callback after each Promise Completes/Fails -- Use for progress tracking
 * @returns A Promise for the whole batch. Captured Errors are in the order they occured
 *  Example:
 * 	PromiseRun(myGenerator() , 2 ).then( ()=>{ all-complete } ).catch( er => { some-error } );
 */
export function PromiseRun(pgen, pmax = 4, pcb) {
    return new Promise((res, rej) => {
        let RUNNING = 0;
        let COMPLETE = 0;
        let ERRORS; // Holds all Errors from Promises to return when all settled
        function tryAdd() {
            // Do not start a new Promise, wait for the current ones to end
            if (ERRORS) {
                if (RUNNING == 0) {
                    L.error(`PromiseRun -- END WITH ERRORS (${ERRORS.length}) -- Run (${COMPLETE})`);
                    return rej(ERRORS);
                }
                return; // has more promises that are running. wait
            }
            let gen = pgen.next(); // Start a new promise
            if (gen.done) {
                if (RUNNING == 0) {
                    L.log(`PromiseRun -- END -- ALL (${COMPLETE}) SETTLED`);
                    return res(0);
                }
                // There are no more Promises to get, but some Promises are still running. wait
                return;
            }
            RUNNING++;
            gen.value
                .catch((er) => {
                if (!ERRORS)
                    ERRORS = [];
                if (er instanceof Error) {
                    ERRORS.push(er.message);
                }
                else {
                    ERRORS.push(er); // Either {String} or {Any}
                }
            })
                .finally(() => {
                COMPLETE++;
                RUNNING--;
                L.debug(`PromiseRun -- Completed (${COMPLETE}) `);
                if (typeof pcb == 'function')
                    pcb(COMPLETE);
                tryAdd();
            });
        } // end tryAdd ;
        // -- Start running promises
        L.log(`PromiseRun -- START -- Max parallel (${pmax})`);
        while (pmax--)
            tryAdd();
        // DEV: I don't need to track Max, because when a Promise ends another takes its place
        //		one Promise spawns one. So it can never exceed {pmax}	
    });
} // -------------------------;
// =======================================
// ARRAY Expansions 
// =======================================
/**  Array.last()
 *
 * Returns the last element of an array
 * - DEV: With this way the function is not iterable
 * - DEV: Other way is `Array.prorotype.last = function()....`
 */
Object.defineProperty(Array.prototype, "last", {
    value: function (n = 1) {
        if (this == null) {
            throw new TypeError('This is null or not defined');
        }
        if (this.length == 0)
            return undefined;
        if (this.length - n < 0)
            return this[0];
        return this[this.length - n];
    },
    writable: false,
    enumerable: false,
    configurable: false
}); // -------------------------;
/**  Array.queueRun()
 *
 * - Calling next() is automatically put on a new event loop tick
 * - You must check for el==null to get when the queue ends
 * - Executes a function for all elements, but only goes to the
 *   next element with a callback.
 * - WARNING. Modifies self, as it works with shift()
 * - e.g:
 * 	[1,2,3].queueRun( (el, next) => {
 * 		doSomethingWith(el);
 * 		if(el==undefined) queueComplete(); else
 * 		next();
 *	});
 */
Object.defineProperty(Array.prototype, "queueRun", {
    value: function (userFn) {
        const T = this;
        const q = () => {
            let el = T.shift();
            userFn.call(T, el, () => {
                process.nextTick(q); // Avoid deep stacks, at a speed cost
            });
        };
        q();
    },
    writable: true,
    enumerable: false,
    configurable: true
}); // -------------------------;
//# sourceMappingURL=Tools.js.map