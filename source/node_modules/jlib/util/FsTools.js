/**
 * Filesystem Tools & Functions
 * --------------------------------
 * Exports : Bundle Object
 */
import FS from 'node:fs';
import PATH from 'node:path';
import L from './Log.js';
/**Like FS.mkdirSync, but doesn't freak out when it is a root drive like "b:\"
 * @returns {Number} Success 1 for OK ; 0 for Error
 */
export function createPath(path) {
    if (!FS.existsSync(path))
        try {
            FS.mkdirSync(path, { recursive: true });
        }
        catch (e) {
            L.error("Cannot create Path : " + path);
            return 0;
        }
    return 1;
} // -------------------------;
/**Useful for filenames. Removes the \ / : " * ? < > | characters
 */
export function sanitizePath(f) {
    return f.replace(/[\\/:"*?<>|]/g, '');
} // -------------------------;
/**SYNC Get contents of a file and return them
 * Returns NULL for any error
 * @param f Filename to load
 * @returns File contents ; Null for Error
 */
export function getFile(f) {
    let contents;
    try {
        contents = FS.readFileSync(f, { encoding: "utf8" });
    }
    catch (e) {
        return null;
    }
    return contents;
} // -------------------------;
/**
 * Read a file as text and return Array, line by line
 * - Automatically handles CRLF and LF
 * - Returns null for error
 **/
export function getFileLines(f) {
    const content = getFile(f);
    if (content === null)
        return null;
    return content.replace('\r\n', '\n').split('\n');
} // -------------------------;
/**Add Binary content from SOURCE to DEST file ( DEST will be created )
 * readStart and readLen are for the Source file.
 * @param source Source File
 * @param dest Destination File (will be created)
 * @param readStart Where in source to start copying
 * @param readLen How many bytes to copy (0) to copy rest of the file
 * @param destMode Dest file open mode | w:write create, a:append create, wx:w + fail if exists, ax:a + fail if exists
 * @returns Promise
 */
export function copyPart(source, dest, readStart = 0, readLen = 0, destMode = 'w') {
    // DEV: I can't just do `async` because I need to be able to call REJECT() from callbacks
    return new Promise((res, rej) => {
        let stat;
        try {
            stat = FS.statSync(source);
        }
        catch (er) {
            throw `Cannot read file '${source}'`; // DEV: Throws here will fail the promise
        }
        let srcSize = stat.size;
        if (readLen == 0)
            readLen = srcSize - readStart;
        else if (readLen + readStart > srcSize) {
            throw `Trying to copy more bytes than available in '${source}'`;
        }
        // DEV: it needs the -1 for readEnd because it is inclusive | i.e. (readStart to readStart) would read 1 byte
        // Actual ending position to read
        let readEnd = readStart + readLen - 1;
        // DEV: - Streams will autoclose, even on error
        // 		- Default buffer size is 64KB `highWaterMark`
        let strIn = FS.createReadStream(source, { start: readStart, end: readEnd, flags: 'r' });
        strIn.once('error', er => rej(`Could not read file '${source}'`));
        let strOut = FS.createWriteStream(dest, { flags: destMode });
        strOut.once('error', er => rej(`Could not write file '${dest}'`));
        L.debug(`Copying "${source}" BYTES [(from)::${readStart} (len)::${readLen} (end)::${readEnd}] to "${dest}"`);
        strIn.pipe(strOut);
        strOut.once('close', res);
    });
    /* DEV: Other manual way of doing it, put pipes work just fine.
        let buffer, bytesLeft = readLen;
        while (bytesLeft > 0) {
            let blen = (bytesLeft >= BUFFERSIZE) ? BUFFERSIZE : bytesLeft;
            buffer = strIn.read(blen);
            strOut.write(buffer);
            bytesLeft -= blen;
        }
        strIn.close(); strOut.close(); */
}
; // -------------------------------------------------------;
/**
 * This is a simple globbing function to get {*.ext} and {*} from a folder
 * Returns Relative Paths, Like BASH
 * ! Case Insensitive
 * @param inp Path to search. e.g. "a:\\*.gif"
 * @return {String[]} List of files found. Only Filenames, NO FULL PATHS, NO DIRS
 * 						Returns [] if error or nothing found
 */
export function dirGlob0(inp, cwd = process.cwd()) {
    let p = PATH.parse(PATH.resolve(inp));
    // console.log(p); // { root: 'c:\\', dir: 'c:\\iso', base: '*.cue', ext: '.cue', name: '*' }
    if (p.name != "*")
        return [];
    p.ext = p.ext.toLocaleLowerCase();
    let all;
    try {
        all = FS.readdirSync(p.dir, { withFileTypes: true });
    }
    catch (e) {
        L.error(`dirGlob0: Could not read "${p.dir}"`);
        return [];
    }
    let out = [];
    all.forEach((f) => {
        if (f.isFile())
            if (!p.ext || (p.ext && f.name.toLocaleLowerCase().endsWith(p.ext)))
                out.push(PATH.relative(cwd, PATH.join(p.dir, f.name)));
    });
    return out;
}
; // -------------------------------------------------------;
//# sourceMappingURL=FsTools.js.map