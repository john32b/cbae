/**
 * Generic Logger
 * - Includes code from the NPM package (GPL-3.0 license) : https://github.com/jinweizhiyuan/logger-line-number
 *
 * DEV:
 * - All terminals display STDOUT+STDERR by default
 *
 *
 * LOG LEVELS:
 * 0:None
 * 1:Error
 * 2:Warning
 * 3:Normal
 * 4:Debug
 *
 * Typescript:
 * 	- strictNullChecks:false // because I am nulling some strings
 *
 * Init Example:
 *
 * L.set({ level: 4, file: "a:\\log.txt", pos: true, stderr: false, date: "" });
 *
 ****************************************************************/
import FS from 'node:fs';
// Default LOG parameters.
const PARAMS = {
    date: "HH:MM:SS",
    pos: false,
    stderr: false,
    bufferSize: 2000,
    file: "",
    level: -1 // Initial Log Level (0:none,1:error,2:warning,3:normal,4:debug)
};
var loglvl = 3; // (3:LOG) Active log level | anything higher than that will not log
var buffer = []; // Keeps all log messages
var logFile; // Path of file to log. "" for no file.
/** Set multiple parameters at once
 * Usually called in Development
 * Log Level : 0:None 1:Error 2:Warning 3:Normal 4:Debug
*/
function set(P) {
    Object.assign(PARAMS, P);
    if (PARAMS.file)
        setLogFile(PARAMS.file);
    if (PARAMS.level >= 0) {
        loglvl = PARAMS.level;
        if (loglvl < 0)
            loglvl = 0;
        else if (loglvl > 4)
            loglvl = 4;
    }
} // -------------------------;
/**
 * Set a file to write the log. If it exists, will be overwritten.
 * @param path Path of a log file to write.
 */
function setLogFile(path) {
    if (logFile == path)
        return; // Rare case e.g. When you want to call set() again to change something
    logFile = path;
    let line = '-'.repeat(40);
    let header = ` == LOG ==
 ${line}
 - LogFile : ${logFile}
 - Created : ${dateFormat("YYYY-mm-dd HH:MM:SS")} 
 - Script  : ${process.argv[1]}
 ${line}
`; // < end with new line
    // < Keep this at most left, since whiteSpace matters
    try {
        FS.writeFileSync(logFile, header); // utf8 is default
    }
    catch (e) {
        logFile = "";
        error(`Cannot Create Log File ${logFile}`);
        return;
    }
    // There is a case where the log array has data,
    // write that data to the file.
    for (let m of buffer)
        pushFile(m);
} //-------------------------;
/**
 * DEV: This has got to be a separate function, don't merge
 */
let getStackTrace = function () {
    let obj = {};
    Error.captureStackTrace(obj, getStackTrace); // Error.captureStackTrace to capture the stack-trace where you throw the error.
    return obj.stack;
}; //-------------------------;
/**
 * Write a string to current logfile.
 * [DEV] logfile was checked before on <setLogFile()>
 */
function pushFile(str) {
    try {
        // logfile already checked to not be null
        FS.appendFileSync(logFile, str + '\n');
    }
    catch (e) {
        logFile = ""; // Don't call for writes anymore
        error("Cannot write to LOG FILE");
    }
} //-------------------------;
/** Helper */
function dateFormat(fmt) {
    let date = new Date();
    let opt = {
        "Y+": date.getFullYear().toString(),
        "m+": (date.getMonth() + 1).toString(),
        "d+": date.getDate().toString(),
        "H+": date.getHours().toString(),
        "M+": date.getMinutes().toString(),
        "S+": date.getSeconds().toString(),
    };
    for (let k in opt) {
        let reg = new RegExp("(" + k + ")");
        let match = reg.exec(fmt);
        if (match) {
            fmt = fmt.replace(match[1], match[1].length == 1 ? opt[k] : opt[k].padStart(match[1].length, "0"));
        }
    }
    return fmt;
} //-------------------------;
/**
 * Called by the more specific functions and does the actual logging
 */
function logMain(...args) {
    let str = args.shift() + ' '; // BUG when printing objects? [object object] WHY?
    if (PARAMS.date) { // works with null and ""
        str += `${dateFormat(PARAMS.date)}|`;
    }
    if (PARAMS.pos) {
        let stack = getStackTrace();
        let matchstack = stack.match(/\(.*?\)/g) || [];
        let line = matchstack[2] || "";
        // Full line is e.g. | (C:\code\Myapp\app.js:32:3)
        let fileAndLine = line.slice(line.lastIndexOf('/') + 1, -1);
        // DEV: ^ I used to get the / with PATH.sep, but it seems that it produces / even on windows
        str += `(${fileAndLine}) `;
    }
    // str is the first part of the log e.g. | "01:18:02 (app.js:33:3) [INFO] "
    // Log to console.log NOW before building the str object more
    // it provides a different format for printing objects and arrays
    if (PARAMS.stderr) {
        console.error(str, ...args); // Write to STDERR
    }
    // Construct a string with the rest of the arguments
    args.forEach((c) => {
        if (typeof c == "object") {
            if (Array.isArray(c)) {
                str += ` [${String(c)}]`;
            }
            else {
                str += ` ${JSON.stringify(c)}`;
            }
        }
        else {
            if (typeof c != "function")
                str += ` ${c}`; // else must be number or string
        }
    });
    // --
    buffer.push(str);
    if (buffer.length > PARAMS.bufferSize)
        buffer.shift(); // remove the oldest;
    if (logFile)
        pushFile(str); // convert to string
} //-------------------------;
/** Log Debug */
function debug(...arg) {
    if (loglvl < 4)
        return;
    logMain('DEBUG', ...arg);
} //-------------------------;
/** Log */
function log(...arg) {
    if (loglvl < 3)
        return;
    logMain('LOG', ...arg);
} //-------------------------;
/** Log Warning */
function warn(...arg) {
    if (loglvl < 2)
        return;
    logMain('WARNING', ...arg);
} // -------------------------;
/** Log Error */
function error(...arg) {
    if (loglvl < 1)
        return;
    logMain('ERROR', ...arg);
} //-------------------------;
// DEV: I can do | import L from 'jlib/Log' | or anything other than L
export default {
    set,
    log,
    error,
    debug,
    warn,
    get BUFFER() { return buffer; }
};
//# sourceMappingURL=Log.js.map