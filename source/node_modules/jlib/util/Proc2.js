/**
 * Proc2 - Process (2) , A level above ChildProcess -- thus the 2
 *
 * - This is just a handy wrapper with boilerplate for spawning processes
 * - Setting onErr,onOut will enable realtime callbacks
 * - logExit is offered when the process exits
 * - log is offered and is built at realtime
 * - Listen to onClose(.) or use startP to get a Promise
 * - You can access stdin normally and pipe to it
 *
 * DEV TIPS:
 * ---------
 * 	-	You can access proc.stdio right after startP. The Promise runs in the same loop
 *		It is the promise handlers that are async
 *
 *  -	When you access the {stdin} make sure you add an error handler
 * 		even an empty one will do | proc.stdin.once('error',()=>{});
 * 		Without it, the main process error event cannot fire
 * 		'new' use the stdin getter
 *
 * HELP -- https://nodejs.org/api/child_process.html#child_processspawncommand-args-options
 *
 ************************************************************************/
import { spawn, execSync } from 'node:child_process';
import L from './Log.js';
export class Proc2 {
    /* Counter for (id) */
    static ID = 0;
    /* Unique id number among Proc2 instances */
    id;
    /* Executable string e.g. "ffmpeg" */
    exec;
    /* Current working Dir */
    cwd;
    /* The actual proc object */
    // TS Trick: strictPropertyInitialization=false
    // This is initialized in start();
    proc;
    /*  Once the App closes (success/fail) will call this one
     *  Parameter is the Exit Code, 0 for Success. You can read logExit for more */
    onClose;
    /** Automatically written when the process exits */
    logExit = { err: '', out: '', code: 0 };
    /** If set, stdout/err will write to it as it gets data
     * DEV: Automatically sets the stream encoding to UTF-8, should be fine
     * DEV: This could be redundant or Rare? since I have {logExit} */
    log;
    /** If set will callback stdErr in Realtime */
    onErr;
    /** @type {cb_string}
     *  If set will callback stdOut in Realtime */
    onOut;
    /**
     * Initialize with vars
     * @param exec Executable to run
     * @param P Extra parameters
     */
    constructor(exec, P) {
        this.id = ++Proc2.ID;
        this.exec = exec;
        this.cwd = P?.cwd;
        this.onClose = P?.onClose;
        this.log = P?.log;
        this.onErr = P?.onErr;
        this.onOut = P?.onOut;
    } // -------------------------;
    /**
     * Return the process STDIN for writing
     * Do this after startP or start
     */
    get stdin() {
        // If I don't add this and an error occurs, it will not send the error event to the process
        // @ts-ignore -- proc is always valid
        this.proc.stdin.once('error', () => { });
        return this.proc.stdin;
    } // -------------------------;
    /** Promise Start, It returns a promise,
     * - DEV: It calls the already set onClose before resolving
     * @param args Normal Array of Strings, or String with `|` separated
     */
    startP(args) {
        return new Promise((res, rej) => {
            this.onClose = (c) => {
                if (c == 0)
                    return res(0);
                rej(this.logExit); // Push the whole thing, let the user decide what to do with it
            };
            this.start(args);
        });
    } // -------------------------;
    /**
     * Start the process using arguments. NodeJS likes arguments in an Array, but you
     * can pass arguments in a single String. Be careful with that, separate args with `|`
     * @param args Normal Array of Strings, or String with `|` separated
     */
    start(args) {
        if (typeof (args) == 'string')
            args = args.split('|');
        L.log(`AppRun (${this.id}): ${this.exec} ${args ? args.join(' ') : ''} | cwd:${this.cwd ?? process.cwd()}`);
        let p = this.proc = spawn(this.exec, args, { cwd: this.cwd });
        if (!this.onClose)
            throw "forgot to set onClose";
        /*  The 'error' event is emitted whenever:
        * - The process could not be spawned, or
        * - The process could not be killed, or
        * - Sending a message to the child process failed.
        */
        p.once('error', er => {
            let el = this.logExit;
            L.error(`AppRun (${this.id}): ERROR ${er.message}`);
            if (er.message.endsWith('ENOENT')) {
                el.err = `Cannot execute "${this.exec}"`;
                el.code = 2; // 2:ENOENT: No such file or directory
                return;
            }
            el.err = er.message;
            el.code = 1;
        });
        /* The 'exit' event is emitted after the child process ends.
        * When the 'exit' event is triggered, child process stdio streams might still be open.
        * This is why I am getting the final stdout.err here
        * DEV: highWaterMark is 16KB, I don't know how to lower it
        * DEV: triggers before 'close' event
        */
        p.once('exit', (code, killsig) => {
            let _e = p.stderr.read();
            let _o = p.stdout.read();
            this.logExit = {
                err: _e ? Buffer.from(_e).toString() : '',
                out: _o ? Buffer.from(_o).toString() : '',
                code: code ?? 0
            };
        });
        /* The 'close' event is emitted when the stdio streams of a child process have been closed.
        * DEV It is safer than 'exit' since 'exit' could emmit while stdio streams are open
        * 	Triggers after 'exit' event
        * 	Error event -> Close event
        */
        p.once('close', (code, killsig) => {
            this.kill(); // Help the GC ?
            let el = this.logExit; // shortcut
            if (code == 0) {
                L.log(`AppRun (${this.id}): CLOSE - OK`);
                // @ts-ignore - checked earlier
                return this.onClose(0);
            }
            // In case 'onError' was called. Keep the custom code
            if (el.code > 0)
                code = el.code;
            else
                // @ts-ignore -- wtf el.code is >0 so it is a number.
                el.code = code;
            // This is normal process exit with some Error Code
            // DEV: 128 from the end should be enough for a quick glance of the error
            L.error(`AppRun (${this.id}): CLOSE - Error Code : ${code}\n` +
                `\tstdErr : ...${el.err.slice(-128)}` +
                `\tstdOut : ...${el.out.slice(-128)}`);
            // @ts-ignore - checked earlier
            return this.onClose(code);
        });
        // DEV: setEncoding("utf8") makes the chunks on "data" event Strings, 
        //		else they would be buffers
        if (this.onErr) {
            p.stderr.setEncoding("utf8");
            p.stderr.on("data", this.onErr);
        }
        if (this.onOut) {
            p.stdout.setEncoding("utf8");
            p.stdout.on("data", this.onOut);
        }
        // -- Log everything here if an object is set
        if (this.log) {
            this.log.err = this.log.out = "";
            p.stderr.setEncoding("utf8");
            // @ts-ignore -- I literally checked for (this.log) in the if statement
            p.stderr.on('data', d => this.log.err += d);
            p.stdout.setEncoding("utf8");
            // @ts-ignore -- I literally checked for (this.log) in the if statement
            p.stdout.on('data', d => this.log.out += d);
        }
    } // -------------------------;
    kill() {
        if (this.proc) {
            this.proc.removeAllListeners(); // Don't callback 'close' event when I force close a process
            this.proc.kill(); // DEV:TODO: I could send a specific signal | https://man7.org/linux/man-pages/man7/signal.7.html
        }
    } // -------------------------;
    /**
     * Tries to run an executable to see if it exists
     * @param comm Command to check/Run
     **/
    static checkRun(comm) {
        try {
            execSync(comm, { timeout: 5000, stdio: 'ignore' });
        }
        catch (e) {
            return false;
        }
        return true;
    } // -------------------------;
}
//# sourceMappingURL=Proc2.js.map