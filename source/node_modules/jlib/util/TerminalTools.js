/**
 * Terminal Related Generic Tools
 *
 ************************************************************/
import T from "jlib/Terminal";
import fs from "node:fs";
/**
 * Capture a string from the keyboard [ENTER] to send it back.
 * - Quick and Dirty Way to get keyboard
 * - CTRL-C is locked, and will emmit a ^C
 *
 * DEV:
 * - This does not need to be async
 * - I could use READLINE? [no]
 * 	^ It is primitive, without colors, or cursor restoration abilities
 */
export async function getInputString() {
    return new Promise((res) => {
        const SIZE = 300; // This many (-2) characters allowed to type
        var bytesin = 0;
        var b = Buffer.alloc(SIZE);
        try {
            bytesin = fs.readSync(process.stdin.fd, b, 0, SIZE, null);
        }
        catch (e) {
            res(""); // Never
        }
        // CTRL-C Does not stop readSync, instead it produces a Buffer filled with 0's
        if (b.readUInt8() == 0)
            return res("^C");
        res(b.toString("utf-8", 0, bytesin - 2)); // -2 to remove the ENTER key
    });
} // -------------------------------------------------------;
/**
 * Generic Progress Counter
 * - Saves Cursor position
 * - Updates a decorative string on a timer
 * - Can show task progress in the form of (1/12)
 * - Prints : "(1/12) ....... "
 *
 * ------
 * example:
 *
 * 	Prog.start(10);	// 10 max tasks
 *  Prog.setTask(5,10);	// CAll this whenever you want. i.e. when a promise ends.
 *  Prog.stop();	// Stops the timer. RETURNS cursor to the end of the line.
 *
 */
export var Prog = {
    active: false,
    tick: 250,
    timer: null,
    t_max: 0,
    t_comp: 0,
    t_str: "",
    c: 1,
    cmax: 7,
    /**
     * Call this right when you want the Progress to start on the CLI
     * Depending on max=0 or not, the (1/12) string will be written
     */
    start(max = 0) {
        T.saveCur();
        if (max > 0)
            this.setTask(0, max); // Start off with 0 tasks completed.
        this.active = true;
        this.timer = setInterval(this._upd.bind(this), this.tick);
        // DEV ^ : SetInterval callback changes "this" so using bind gives it back to this
    },
    // DEV: 
    // The Final display string consists of two (2) parts
    // 		Part 1, task progress : "(1/12) "
    // 		Part 2, decorative : " ....... "
    // - Part 2 updates more frequently than part 1 on a timer
    // - Part 1 updates on user call
    // ===> This is why I decided to have two (2) update/print functions
    // upd1() -> updates the pre string "(1/12) " and prints that on screen
    // upd2() -> Only updates the decorative string "...."
    //
    setTask(a, b) {
        // Clear the previous "(1/23) " line and print on top of it
        // > Warning the line could expand by a few characters
        //   but upd2() compensates by printing next to it and erasing the line
        T.loadCur().print(' '.repeat(this.t_str.length)).loadCur();
        T.pac(this.t_str = `(${a}\/${b}) `);
    },
    _upd() {
        T.loadCur();
        if (this.t_str) { // move past the (1/12) string
            T.moveR(this.t_str.length, 0);
        }
        T.clearLine(1).print('.'.repeat(this.c));
        if (++this.c > this.cmax)
            this.c = 1;
    },
    /** Restore Cursor and delete string */
    stop() {
        if (!this.active)
            return false;
        clearInterval(this.timer);
        T.loadCur().clearLine(1);
        this.active = false;
        return true;
    }
}; // -------------------------------------------------------;
//# sourceMappingURL=TerminalTools.js.map